using System;
using System.Text;
using DiscUtils.Fat;
using DiscUtils.Internal;


namespace DiscUtils.Vfat
{
    internal class VfatFileName : FileName
    {
        // Each part contains 10+12+4 = 26 bytes.
        private const int partSize = 26;

        private byte[] _bytes;
        private byte _lastPart;

        public static VfatFileName FromPath(string path, VfatFileSystem system)
        {
            return FromName(Utilities.GetFileFromPath(path), system, system.GetUniqueIndex(Utilities.GetFileFromPath(path),
                Utilities.GetDirectoryFromPath(path)));
        }

        public static VfatFileName FromName(string name, VfatFileSystem system,  int index)
        {
            var options = (VfatFileSystemOptions)system.FatOptions;

            return new VfatFileName(GetShortName(name, index), name, options.PrimaryEncoding, options.SecondaryEncoding);
        }

        public static string GetShortName(string strLongName, int nIndex) {
            // Split out name (without extension) and extension
            // Note that the "extension" includes everything after the first dot, including other dots
            string strNameWithoutExtension, strExtension;
            int nFirstDotIndex = strLongName.IndexOf('.');

            if (nFirstDotIndex == -1) {
                strNameWithoutExtension = strLongName;
                strExtension = "";
            } else {
                strNameWithoutExtension = strLongName.Substring(0, nFirstDotIndex);
                strExtension = strLongName.Substring(nFirstDotIndex + 1);
            }

            // Check if name is already 8.3 and won't conflict with autogenerated short names
            if ((strNameWithoutExtension.Length <= 8) && (strNameWithoutExtension.Length > 0) && (strExtension.Length <= 3)
                && !ContainsCharacters(strExtension, DOS_INVALID_CHARS) && !strNameWithoutExtension.Contains("~")
                && !ContainsCharacters(strNameWithoutExtension, DOS_INVALID_CHARS))
                return strLongName.ToUpperInvariant();

            // Get index as string
            if (nIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(nIndex));
            string strIndex = nIndex.ToString();
            if (strIndex.Length > 7)
                throw new ArgumentOutOfRangeException(nameof(nIndex));

            // Remove invalid characters from names
            strNameWithoutExtension = RemoveCharacters(strNameWithoutExtension, DOS_INVALID_CHARS);
            strExtension = RemoveCharacters(strExtension, DOS_INVALID_CHARS);

            // Get extra-short name (without extension) and short extension
            int nExtraShortNameLength = 8 - (1 + strIndex.Length);
            string strExtraShortName = (strNameWithoutExtension.Length < nExtraShortNameLength) ? strNameWithoutExtension
                : strNameWithoutExtension.Substring(0, nExtraShortNameLength);
            string strShortExtension = (strExtension.Length < 3) ? strExtension : strExtension.Substring(0, 3);

            strExtraShortName = strExtraShortName.ToUpperInvariant();
            strShortExtension = strShortExtension.ToUpperInvariant();

            // Format 8.3 name
            return string.Format("{0}~{1}.{2}", strExtraShortName, strIndex, strShortExtension);
        }

        private const string DOS_INVALID_CHARS = "\"*+,/:;<=>?\\[]|.";

        private static bool ContainsCharacters(string strCheck, string strCharactersToCheckFor) {
            foreach (char c in strCheck)
                if (strCharactersToCheckFor.IndexOf(c) != -1)
                    return true;

            return false;
        }

        private static string RemoveCharacters(string strTarget, string strCharactersToRemove) {
            string strModified = "";

            foreach (char c in strTarget)
                if (strCharactersToRemove.IndexOf(c) == -1)
                    strModified += c;

            return strModified;
        }

        public const int INDEX_MAX = 9999999;

        public VfatFileName(string primaryName, string secondaryName, Encoding primaryEncoding, Encoding secondaryEncoding)
            : base(primaryName, primaryEncoding)
        {
            byte[] bytes = secondaryEncoding.GetBytes(secondaryName + "\u0000");

            // Integer division intentional
            _lastPart = (byte)(bytes.Length / partSize);

            // We want the array bigger than we need
            _bytes = new byte[(_lastPart + 1) * partSize];

            for (int i = 0; i < _bytes.Length; ++i) _bytes[i] = 0xff;

            Array.Copy(bytes, _bytes, bytes.Length);
        }

        public byte LastPart { get { return _lastPart; } }

        public void GetPart1(int part, byte[] data, int offset)
        {
            var pos = part * partSize;
            Array.Copy(_bytes, pos, data, offset, 10);
        }
        public void GetPart2(int part, byte[] data, int offset)
        {
            var pos = part * partSize;
            Array.Copy(_bytes, pos + 10, data, offset, 12);
        }

        public void GetPart3(int part, byte[] data, int offset)
        {
            var pos = part * partSize;
            Array.Copy(_bytes, pos + 22, data, offset, 4);
        }

        public byte Checksum()
        {
            byte sum = 0;
            foreach (byte b in Raw)
                sum = (byte)(((sum & 1) << 7) + (sum >> 1) + b);

            return sum;
        }
    }
}
